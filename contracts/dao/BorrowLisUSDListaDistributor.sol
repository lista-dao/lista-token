// SPDX-License-Identifier: MIT
pragma solidity ^0.8.10;

import "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol";
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import "./CommonListaDistributor.sol";

/**
  * @title BorrowLisUSDListaDistributor
  * @notice Stores user's reward data when an user borrows LisUSD by deposit different kind of collaterals
  * @dev This contract stores user debt separated by collateral
  *      reward data and the total debt are stored in the parent contract
  */
contract BorrowLisUSDListaDistributor is CommonListaDistributor, ReentrancyGuard {

  // indicates that collateral is enabled or not
  // token -> bool
  mapping(address => bool) public collateralEnabled;
  // debt of each account generated by borrowing LisUSD from collateral
  // token -> account -> debt
  mapping(address => mapping(address => uint256)) public debtByCollateral;

  // event emitted when collateral is toggled
  event CollateralToggled(address token, bool enabled);

  /// @custom:oz-upgrades-unsafe-allow constructor
  constructor() {
    _disableInitializers();
  }

  /**
    * @dev Initialize contract
    * @param _name lp token name
    * @param _symbol lp token symbol
    * @param _admin admin address
    * @param _manager manager address
    * @param _vault vault address
    * @param _lpToken lp token address
    */
  function initialize(
    string memory _name,
    string memory _symbol,
    address _admin,
    address _manager,
    address _vault,
    address _lpToken
  ) external initializer {
    require(_admin != address(0), "admin cannot be a zero address");
    require(_manager != address(0), "manager cannot be a zero address");
    require(_lpToken != address(0), "lp token cannot be a zero address");
    __AccessControl_init();

    _setupRole(DEFAULT_ADMIN_ROLE, _admin);
    _setupRole(MANAGER, _manager);
    _setupRole(VAULT, _vault);
    name = _name;
    symbol = _symbol;
    lpToken = _lpToken;
    vault = IVault(_vault);
  }


  /**
    * @dev set collateral enabled or disabled
    * @param token collateral token address
    * @param enabled enabled or disabled
    */
  function setCollateralEnabled(address token, bool enabled) onlyRole(DEFAULT_ADMIN_ROLE) external {
    collateralEnabled[token] = enabled;
    emit CollateralToggled(token, enabled);
  }


  /**
    * @dev take snapshot of user's activity
    * @param token collateral token address
    * @param user user address
    * @param debt user's latest debt by borrowing LisUSD from the collateral
    */
  function takeSnapshot(address token, address user, uint256 debt) nonReentrant onlyRole(MANAGER) external {
    // check whether collateral is enabled or not
    require(collateralEnabled[token], "collateral is not enabled");
    // For this collateral, if the latest debt is larger than the previous one
    // call _deposit(user, debt diff.), otherwise call _withdraw(user, debt diff.)
    if (debt > debtByCollateral[token][user]) {
      _deposit(user, debt - debtByCollateral[token][user]);
    } else {
      _withdraw(user, debtByCollateral[token][user] - debt);
    }
  }
}
