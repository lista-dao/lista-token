// SPDX-License-Identifier: MIT
pragma solidity ^0.8.10;

import "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol";
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import "./CommonListaDistributor.sol";

/**
  * @title BorrowLisUSDListaDistributor
  * @notice Stores user's reward data when an user borrows LisUSD by deposit different kind of collaterals
  * @dev This contract stores user debt separated by collateral
  *      reward data and the total debt are stored in the parent contract
  */
contract BorrowLisUSDListaDistributor is CommonListaDistributor {

  // debt of each account generated by borrowing LisUSD from collateral
  // token -> account -> debt
  mapping(address => mapping(address => uint256)) public debtByCollateral;

  /// @custom:oz-upgrades-unsafe-allow constructor
  constructor() {
    _disableInitializers();
  }

  /**
    * @dev Initialize contract
    * @param _name lp token name
    * @param _symbol lp token symbol
    * @param _admin admin address
    * @param _manager manager address
    * @param _vault vault address
    * @param _lpToken lp token address
    */
  function initialize(
    string memory _name,
    string memory _symbol,
    address _admin,
    address _manager,
    address _vault,
    address _lpToken
  ) external initializer {
    require(_admin != address(0), "admin cannot be a zero address");
    require(_manager != address(0), "manager cannot be a zero address");
    require(_lpToken != address(0), "lp token cannot be a zero address");
    require(_vault != address(0), "vault is the zero address");
    __AccessControl_init();

    _setupRole(DEFAULT_ADMIN_ROLE, _admin);
    _setupRole(MANAGER, _manager);
    _setupRole(VAULT, _vault);
    name = _name;
    symbol = _symbol;
    lpToken = _lpToken;
    vault = IVault(_vault);
  }

  /**
    * @notice take snapshot of user's activity
    * @dev only the Interaction contract(Manager Role) can call this function,
           it will do the checking in the Interaction Contract,
           so there is no need to add checking here
    * @param token collateral token address
    * @param user user address
    * @param debt user's latest debt by borrowing LisUSD from the collateral
    */
  function takeSnapshot(address token, address user, uint256 debt) onlyRole(MANAGER) external {
    // For this collateral, if the latest debt is larger than the previous one
    // call _deposit(user, debt diff.), otherwise call _withdraw(user, debt diff.)
    if (debt > debtByCollateral[token][user]) {
      _deposit(user, debt - debtByCollateral[token][user]);
    } else {
      _withdraw(user, debtByCollateral[token][user] - debt);
    }
    // update debt of this collateral
    debtByCollateral[token][user] = debt;
  }
}
